from flask import Blueprint, request
import subprocess
import os
import json
import requests
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill
import datetime

# Create a Flask Blueprint for the exploits_table routes
exploits_table_routes = Blueprint("exploits_table", __name__)


@exploits_table_routes.route("/make-exploits-table", methods=["POST"])
def make_table():
    # Check if a file is uploaded
    if "file" not in request.files:
        return "No file uploaded", 400

    file = request.files["file"]
    if file.filename == "":
        return "No file selected", 400

    # Check the file extension to handle both XML and PDF
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in [".xml", ".pdf"]:
        return "Invalid file format. Only XML and PDF files are allowed.", 400

    # Download known exploited vulnerabilities (kev) JSON data from CISA
    kev_url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
    response = requests.get(kev_url)
    if response.status_code == 200:
        with open(os.path.join("info", "kev.json"), "wb") as kev_file:
            kev_file.write(response.content)

    # Save the uploaded file
    filename = "ExploitsTable"
    file_path = os.path.join(
        os.path.dirname(__file__), "uploads", filename + file_extension
    )
    file.save(file_path)

    # Paths for output files
    output_file_cve = os.path.join(
        os.path.dirname(__file__), "output", "exploits_table", "CveList.txt"
    )
    output_file_exploits_temp = os.path.join(
        os.path.dirname(__file__), "output", "exploits_table", "ExploitsTableTemp.json"
    )

    # Modify the extract_cve_command based on the file extension
    if file_extension == ".xml":
        extract_cve_command = f"xpath -e '//@ref_id' {file_path} | grep 'CVE' | sed -r 's/^.*CVE-([0-9]{{4}})-([0-9]{{4,7}}).*$/\\1-\\2/g' | sort | uniq > '{output_file_cve}'"
    else:  # For PDF files
        extract_cve_command = f"pdfgrep '[0-9]{{4}}-[0-9]{{4,7}}' '{file_path}' | sed -r 's/^.*([0-9]{{4}}-[0-9]{{4,7}}).*$/\\1/g' | sort | uniq > '{output_file_cve}'"

    subprocess.run(extract_cve_command, shell=True)

    # Read the extracted CVEs from the text file
    cve_list = []
    with open(output_file_cve, "r") as cve_file:
        cve_list = cve_file.read().splitlines()

    # Extract exploit data for each CVE and save it to a JSON file
    exploits_data = []
    for cve in cve_list:
        search_exploit_command = (
            f"searchsploit --cve {cve} -j > '{output_file_exploits_temp}'"
        )
        subprocess.run(search_exploit_command, shell=True)
        with open(output_file_exploits_temp) as exploits_file:
            expl_j_data = json.load(exploits_file)
            cve_data = {cve: expl_j_data["RESULTS_EXPLOIT"]}
            exploits_data.append(cve_data)

    # Create an Excel table with the extracted data
    current_datetime = datetime.datetime.now().strftime("%d%m%y_%H%M")
    output_file_excel = os.path.join(
        os.path.dirname(__file__),
        "output",
        "exploits_table",
        f"Exploits_{current_datetime}.xlsx",
    )
    create_excel_table(exploits_data, output_file_excel)

    # Provide a download link for the generated Excel file
    download_link = request.host_url + f"download/{current_datetime}"
    return {"downloadLink": download_link, "timestamp": current_datetime}


# Function to check CVE information in the downloaded kev JSON file
def check_cve_kev(cve):
    with open(os.path.join("info", "kev.json")) as kev_file:
        kev_data = json.load(kev_file)
        vulnerabilities = kev_data.get("vulnerabilities", [])
        for vulnerability in vulnerabilities:
            if ("CVE-" + cve) == vulnerability.get("cveID"):
                return vulnerability
        return None


# Function to create an Excel table from the extracted data
def create_excel_table(exploits_data, output_file):
    # Create a new Excel workbook and set up the worksheet
    wb = Workbook()
    ws = wb.active
    ws.title = "Exploits"

    # Define the table headers and chapters
    chapters = [
        "ExploitDB",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "Known Exploited Vulnerabilities",
    ]
    headers = [
        "â„–",
        "CVE ID",
        "Date published",
        "Date updated",
        "Title",
        "EDB-ID",
        "Type",
        "Platform",
        "URL",
        "Product",
        "Description",
        "Required action",
        "Notes",
    ]

    # Write chapters and headers to the worksheet
    ws.append(chapters)
    ws.append(headers)
    ws.freeze_panes = "A3"

    # Apply formatting to the headers
    bold_font_header = Font(bold=True, size=13)
    olive_fill = PatternFill(
        start_color="ff4aa71b", end_color="ff4aa71b", fill_type="solid"
    )
    for row in ws.iter_rows(min_row=1, max_row=2, min_col=1, max_col=9):
        for cell in row:
            cell.fill = olive_fill

    light_blue_fill = PatternFill(
        start_color="FFADD8E6", end_color="FFADD8E6", fill_type="solid"
    )
    for row in ws.iter_rows(min_row=1, max_row=2, min_col=10, max_col=13):
        for cell in row:
            cell.fill = light_blue_fill

    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=9)
    ws.merge_cells(start_row=1, start_column=10, end_row=1, end_column=13)

    # Write exploit data to the worksheet
    row_number = 0
    for exploit in exploits_data:
        for cve, results in exploit.items():
            if results:
                for result in results:
                    kev_vulnerability = check_cve_kev(cve)
                    if "Codes" in result and ("CVE-" + cve) in result["Codes"].split(
                        ";"
                    ):
                        row_number += 1
                        row = [
                            row_number,
                            "CVE-" + cve,
                            result.get("Date_Published", ""),
                            result.get("Date_Updated", ""),
                            result.get("Title", ""),
                            result.get("EDB-ID", ""),
                            result.get("Type", ""),
                            result.get("Platform", ""),
                            f"https://www.exploit-db.com/exploits/{result.get('EDB-ID', '')}",
                        ]
                        if kev_vulnerability:
                            row.extend(
                                [
                                    kev_vulnerability.get("product", ""),
                                    kev_vulnerability.get("shortDescription", ""),
                                    kev_vulnerability.get("requiredAction", ""),
                                    kev_vulnerability.get("notes", ""),
                                ]
                            )
                        else:
                            row.extend(["", "", "", ""])
                        ws.append(row)

    # Add hyperlinks to the "URL" column
    for row in ws.iter_rows(min_row=3, min_col=9, max_col=9):
        for cell in row:
            cell.hyperlink = cell.value

    # Adjust column widths and apply formatting
    max_column_width = 70
    for column in ws.columns:
        max_length = 10
        column_letter = column[1].column_letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = min(max_length + 2, max_column_width)
        ws.column_dimensions[column_letter].width = adjusted_width * 1.15

        for cell in column:
            cell.alignment = Alignment(horizontal="center", vertical="center")
            if cell.column in [5, 11, 12, 13]:
                cell.alignment = Alignment(
                    horizontal="center", vertical="center", wrap_text=True
                )
            if cell.row == 1 or cell.row == 2:
                cell.font = bold_font_header
            else:
                cell.font = Font(size=13)

    # Save the workbook as an Excel file
    wb.save(output_file)
